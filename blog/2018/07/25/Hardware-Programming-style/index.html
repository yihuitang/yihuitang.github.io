<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus v2.0.0-alpha.58">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/video.js/dist/video-js.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@videojs/themes@1/dist/fantasy/index.css">
<script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lettering.js/0.6.1/jquery.lettering.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/video.js/dist/video.min.js"></script>
<script src="/script/settheme.js"></script><title data-react-helmet="true">两种硬件编程风格的比较 | CodeLab</title><meta data-react-helmet="true" property="og:title" content="两种硬件编程风格的比较 | CodeLab"><meta data-react-helmet="true" name="description" content="原文地址：两种硬件编程风格的比较"><meta data-react-helmet="true" property="og:description" content="原文地址：两种硬件编程风格的比较"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/styles.84b1147b.css">
<link rel="preload" href="/styles.71fb8b2a.js" as="script">
<link rel="preload" href="/runtime~main.676e3002.js" as="script">
<link rel="preload" href="/main.aad9f3c1.js" as="script">
<link rel="preload" href="/1.af123087.js" as="script">
<link rel="preload" href="/2.2944d33e.js" as="script">
<link rel="preload" href="/3.ffbe02f2.js" as="script">
<link rel="preload" href="/ccc49370.9d6295d9.js" as="script">
<link rel="preload" href="/c75b8501.558fbb50.js" as="script">
</head>
<body>
<div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/logo.png" alt="My Site Logo"></a><a href="https://create.codelab.club" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">创作平台</a><a class="navbar__item navbar__link" href="/projects">玩给你看</a><a href="https://create.codelab.club/ideas#course" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">课程</a><a href="https://adapter.codelab.club/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">文档</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">博客</a><a class="navbar__item navbar__link" href="/blog/2020/09/25/about-codelab-2020">关于我们</a><a href="https://github.com/CodeLabClub" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a></div><div class="navbar__items navbar__items--right"></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/logo.png" alt="My Site Logo"></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a href="https://create.codelab.club" target="_blank" rel="noopener noreferrer" class="menu__link">创作平台</a></li><li class="menu__list-item"><a class="menu__link" href="/projects">玩给你看</a></li><li class="menu__list-item"><a href="https://create.codelab.club/ideas#course" target="_blank" rel="noopener noreferrer" class="menu__link">课程</a></li><li class="menu__list-item"><a href="https://adapter.codelab.club/" target="_blank" rel="noopener noreferrer" class="menu__link">文档</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/blog">博客</a></li><li class="menu__list-item"><a class="menu__link" href="/blog/2020/09/25/about-codelab-2020">关于我们</a></li><li class="menu__list-item"><a href="https://github.com/CodeLabClub" target="_blank" rel="noopener noreferrer" class="menu__link header-github-link"></a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--8 col--offset-2"><article><header><h1 class="margin-bottom--sm blogPostTitle_kDB-">两种硬件编程风格的比较</h1><div class="margin-vert--md"><time datetime="2018-07-25T00:00:00.000Z" class="blogPostDate_2HVl">2018年7月25日   · 2 min 阅读时长</time></div><div class="avatar margin-vert--md"><div class="avatar__intro"></div></div></header><section class="markdown"><div class="alert alert-success">原文地址：<a href="https://blog.just4fun.site/Hardware-Programming-style.html">两种硬件编程风格的比较</a></div><img class="img-responsive" src="/img/message_a34afc78.png"><blockquote><p> 人的心智活动透过简单的概念而发挥它的力量，方法主要可分为三种：第一，把数个简单的概念组合成一个复合的概念，于是所有复杂的概念成焉。第二，将两个概念，不论简单或复杂，不将它们结合，而是同时并列在一起观察，如此就能得知何为相互关联。第三，把某些概念，与伴随它们其他真实存在的概念区隔出来，称为这抽象艺术化，所有一般化，概化的概念皆是由此而生  - 约翰·洛克《人类理解论》</p></blockquote><p>在<a href="https://blog.just4fun.site/scratch3-microbit.html">scratch3.0 + micro:bit</a>中，我们提到</p><blockquote><p> 在少儿编程/硬件编程教育领域，硬件编程有两种风格，我将这两种风格分别称为<code>灌入式</code>和<code>交互式</code></p></blockquote><p>我相信就编程教育而言，<code>交互式</code>优于<code>灌入式</code></p><p>这篇文章我们将讨论这两种编程风格给学习者的编程体验 以及心理状态所带来的影响。所谈论的很多内容，在编程语言的发展历史中都被反复讨论过。</p><p>本文中，我们只讨论图形化硬件编程，但得出的结论并不局限于此</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="灌入式"></a>灌入式<a aria-hidden="true" tabindex="-1" class="hash-link" href="#灌入式" title="Direct link to heading">#</a></h3><p><code>灌入式</code>阵营有名的图形化项目包括：</p><ul><li><a href="https://www.microsoft.com/en-us/makecode" target="_blank" rel="noopener noreferrer">makecode</a></li><li><a href="https://github.com/bbcmicrobit/PythonEditor" target="_blank" rel="noopener noreferrer">PythonEditor</a></li><li><a href="http://mixly.org/" target="_blank" rel="noopener noreferrer">mixly</a></li><li>以及国内大多数项目(makeblock、mcookie...)</li></ul><p>事实上，几乎所有传统的硬件编程都是灌入式的</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="编程方式"></a>编程方式<a aria-hidden="true" tabindex="-1" class="hash-link" href="#编程方式" title="Direct link to heading">#</a></h5><p>我们以<a href="https://pxt.microbit.org/" target="_blank" rel="noopener noreferrer">makecode microbit</a>为例，来展示灌入式编程的编程方式.</p><img src="/img/microbit_gr_de9399e6.png" width="500"><p>在<a href="https://pxt.microbit.org/" target="_blank" rel="noopener noreferrer">makecode microbit</a>中，通过拖拽积木，拼搭出我们的程序，接着将程序下载到本地（程序在线上完成编译），最后将下载的文件拖入micro:bit，即可运行。</p><p>将代码/固件灌入硬件中，代码(代码编译出的固件)将在硬件运行。我将这种编程风格称为<code>灌入式</code>。</p><p>如果你熟悉blockly,你会发现这是一种典型的blockly风格(当然，blockly也可以写出交互式风格的blockly app)</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="交互式"></a>交互式<a aria-hidden="true" tabindex="-1" class="hash-link" href="#交互式" title="Direct link to heading">#</a></h3><p><code>交互式</code>阵营的图形化编程项目有:</p><ul><li><a href="https://www.anki.com/en-us/cozmo/code-lab" target="_blank" rel="noopener noreferrer">Cozmo code lab</a></li><li><a href="https://en.scratch-wiki.info/wiki/PicoBoard" target="_blank" rel="noopener noreferrer">scratch Picoboard</a></li><li><a href="http://s4a.cat/" target="_blank" rel="noopener noreferrer">S4A</a></li><li><a href="https://llk.github.io/scratch-gui/microbit/" target="_blank" rel="noopener noreferrer">scratch microbit extension</a></li><li><a href="https://blog.just4fun.site/lab/codelab-adapter-docs/" target="_blank" rel="noopener noreferrer">codelab-adapter</a></li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="编程方式-1"></a>编程方式<a aria-hidden="true" tabindex="-1" class="hash-link" href="#编程方式-1" title="Direct link to heading">#</a></h5><p>我们以<a href="https://www.anki.com/en-us/cozmo/code-lab" target="_blank" rel="noopener noreferrer">cozmo code lab</a>为例，来展示<code>交互式</code>编程的编程方式.</p><p><img src="/img/cozmof70f49bd.png"></p><p>在<a href="https://www.anki.com/en-us/cozmo/code-lab" target="_blank" rel="noopener noreferrer">cozmo code lab</a>中，你同样身处积木化的编程界面里，通过拖拽积木，拼搭出所需的程序，点击运行，cozmo即可按照程序的逻辑运行。</p><p>程序运行在ipad/手机上，每个积木在实际执行的时候，将消息发给cozmo，从而控制cozmo，这是我将这种风格程序成为<code>交互式</code>的原因</p><p>在<a href="https://www.anki.com/en-us/cozmo/code-lab" target="_blank" rel="noopener noreferrer">cozmo code lab</a>中一个非常惊艳的编程体验是:如果你不知道一个积木有什么作用，你不必去翻说明书，你只需要点击一下这个积木，cozmo立马执行这个积木的逻辑，你可以直观地理解陌生的积木。交互式编程所具有的及时反馈特性，鼓励学习者去探索。这是交互式编程给学习者心理上带来的影响之一。</p><p><a href="https://zh.wikipedia.org/wiki/%E5%BB%BA%E6%A7%8B%E4%B8%BB%E7%BE%A9_(%E5%AD%B8%E7%BF%92%E7%90%86%E8%AB%96)" target="_blank" rel="noopener noreferrer">建构主义</a>者(如皮亚杰、艾伦凯、派普特)应该会喜欢这种风格</p><p>如果你熟悉scratch，你会发现这是一种典型的<code>scratch</code>风格（对象响应消息，很<a href="https://zh.wikipedia.org/zh-hans/Smalltalk" target="_blank" rel="noopener noreferrer">Smalltalk</a>）。关于scratch风格和blockly风格的比较可以参考我之前的文章:<a href="https://blog.just4fun.site/scratch3-blockly.html">Blockly与Scratch3.0的比较分析及选型建议</a></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="对比分析"></a>对比分析<a aria-hidden="true" tabindex="-1" class="hash-link" href="#对比分析" title="Direct link to heading">#</a></h1><blockquote><p> 真理越辩越明</p></blockquote><p>在此我们来对比分析一下<code>灌入式</code>和<code>交互式</code>各自的优势</p><p>灌入式阵营可能列出的优势有:</p><ol><li>灌入式可以离线运行，只需要将代码烧入进去，即可脱离编程工具</li><li>灌入式将带来优于交互式的实时性</li><li>灌入式因为需要generate代码，学生可以查看代码</li></ol><p>如果有遗漏，欢迎拥护<code>灌入式</code>编程的小伙伴来信(<a href="mailto:wuwenjie@codelab.club">wuwenjie@codelab.club</a>)补充</p><p>由于我拥护<code>交互式</code>编程，所以我准备在下文里，反驳<code>灌入式</code>的优势，并指出<code>交互式</code>所具有的优势。如果你不赞同，欢迎来信反驳，观点合理的话，我会及时更新到本文，如有必要，我们也可以使用<a href="https://www.kialo.com/" target="_blank" rel="noopener noreferrer">理性辩论的平台 Kialo</a>来进行辩论</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="反驳灌入式的优势"></a>反驳灌入式的优势<a aria-hidden="true" tabindex="-1" class="hash-link" href="#反驳灌入式的优势" title="Direct link to heading">#</a></h3><p>我们针对上边<code>灌入式</code>阵营提出的三条优势，逐条反驳</p><blockquote><p>   灌入式可以离线运行，只需要将代码烧入进去，即可脱离编程工具</p></blockquote><p>这个论述本身并没有需要反驳的地方，它只是陈述了一个事实，在此我想提出的是，对于教育而言，<code>离线运行</code>不是很重要的特性，如果是工业级的项目或者解决具体问题的硬件产品，离线运行可能是重要的，但对于教育项目而言，我认为这个特性并不重要，如果你实在不愿意一直开着电脑，你可以把上位机运行在树莓派里，若嫌贵，可以使用荔枝派(只要9块9哦)。但需要提醒的是，为了得到<code>离线运行</code>的特性，我们很可能会失去交互性(这个问题不是很好谈论，如果需要,我们之后专门来说说这两个特性在什么情况可能冲突，而不可兼得)。</p><blockquote><p>   灌入式将带来优于交互式的实时性</p></blockquote><p>和上一条观点一样，我认为<code>实时性</code>在编程教育中并不重要。我将<code>离线运行</code>和<code>实时性</code>视为一种对机器性能的优化，前者节约资源、后者节约时间，但这种节约下来的时间，短得也许人类不能感知。我承认在一些竞技类的比赛中，<code>实时性</code>是至关重要的，但在教育中，尤其是低龄化编程教育中，被教育者是这件事的核心，我认为这些特性并不重要，尤其是考虑到这些特性可能和交互性冲突</p><blockquote><p>   灌入式因为需要generate代码，学生可以查看代码</p></blockquote><p>给用户呈现积木所对应的代码，是个帮助用户从图形化过度到文本编程的好办法. 但generate代码这件事并不限于<code>灌入式</code>,<code>交互式</code>的编程界面里，虽然你并不需要generate代码，但如果愿意，完全可以为每个积木生成对应的代码，而且可以是<code>任何语言，任何抽象粒度</code>。<code>灌入式</code>阵营的小伙伴可能会反驳说，你们generate的代码并不是真正用于运行的。我会回答说: 对，我恰恰认为，不该把真正执行的代码generate出来给用户看。积木之所以是个好工具，正是因为它能自如地隐藏复杂度，暴露出合适粒度的概念颗粒，积木并不只是帮助我们省去记忆语法规则，更重要的是，它允许我们根据学生所处的阶段，给予他不同抽象程度的积木。我很喜欢来自lisp社区的忠告:<code>表达你的意图，而不是操作过程，这样有助于我们能站在更高的抽象层面上</code></p><p>关于这一点，<a href="code.org">code.org</a>给了我们很好的示范，一个学习者，在<a href="code.org">code.org</a>里在拖拽了两个积木之后，他看到页面里愤怒的小鸟往东飞一步，接着又往北飞一步，最后成功击中了小猪。</p><p>如果学习者愿意，他可以看看与积木等价的代码：</p><img src="/img/codeorg_9b3de524.png" width="600"><p>我们看到，这些代码隐藏了很多实现的细节，你也许要抱怨说code.org在欺骗学习者，这并不是真正运行的代码，<code>真正的代码</code>是由js在操控svg的元素，但你确定你要给出这个粒度的东西吗？<code>真正的代码</code>也许是一串<code>001101101...</code>. 我认为平台给出合适抽象粒度的积木在编程教育里是至关重要的</p><p>就这点而言，目前很多灌入式的图形化编程并不适合编程教育，尤其不适合少儿编程，他们直接把驱动硬件代码包装到积木下就了事了，积木颗粒在抽象程度上与硬件文本编程无异。如何设计出合适抽象粒度的积木块，不是个简单的问题，我认为这块的从业者都该多看看cozmo和makecode</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="交互式的优势"></a>交互式的优势<a aria-hidden="true" tabindex="-1" class="hash-link" href="#交互式的优势" title="Direct link to heading">#</a></h3><p>反驳完灌入式的优势，接着我们来谈谈<code>交互式</code>的优势何在，我先简单列出，之后逐条陈述</p><ol><li>及时的反馈</li><li>允许单步调试</li><li>软件编程和硬件编程，不必区分，虚拟人物与现实硬件能彼此联动</li><li>强大的可扩展性</li></ol><p>罗列完<code>交互式</code>的优势后，我们来逐条陈述它们.</p><blockquote><p>   及时的反馈</p></blockquote><p>我认为这一条，对编程教育是至关重要的。</p><p>我们从<code>REPL</code>（Read-Eval-Print-Loop）说起，<a href="https://zh.wikipedia.org/wiki/LISP" target="_blank" rel="noopener noreferrer">LISP</a>最早为我们带来<a href="https://zh.wikipedia.org/zh-hans/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">REPL</a>。REPL是个交互式的编程环境，用户输入的表达式及时被求值运行，并输出，这对于学习一门新的编程语言有很大的帮助，因为它能立刻对初学者做出回应，所以这个概念被移植到很多编程语言环境里（Python, Scala , Java(since jdk-9)...）。这种交互式的编程环境使得探索性的编程和调试更加便捷，因为“读取-求值-输出”循环通常会比经典的“编辑-编译-运行-调试”模式要更快，这两者的差异很像<code>交互式</code>和<code>灌入式</code>的差异。我自己使用REPL的一个强烈感受是，在REPL环境中（如ipython），我更乐于探索，对于不懂的api，我会直接做个实验，看看效果，获得直观感受。REPL鼓励每个人在探索中成为自己知识的构建者。而这点正式是早期致力于推广少儿编程的先驱们(艾伦凯、派普特)所追求的</p><p>我将硬件编程里的<code>交互式</code>编程方式，视为一种硬件编程的<code>REPL</code>。如同我在前头举例说的</p><blockquote><p> 在<a href="https://www.anki.com/en-us/cozmo/code-lab" target="_blank" rel="noopener noreferrer">cozmo code lab</a>中一个非常惊艳的编程体验是:如果你不知道一个积木有什么作用，你不必去翻说明书，你只需要点击一下这个积木，cozmo立马执行这个积木的逻辑，你可以直观地理解陌生的积木。交互式编程所具有的及时反馈特性，鼓励学习者去探索系统。这是交互式编程给学习者心理上带来的影响之一。</p></blockquote><p>对教学和平台而言，及时的反馈也能带来诸多好处，有了来自硬件的反馈信息，我们可以在平台中给出更多的提示信息，来指导学生修正错误，或者引导他抵达目标，目前国外社区已经有这块的试水者，我正在关注，之后有机会专门写一篇文章。</p><blockquote><p>   允许单步调试</p></blockquote><p>如果学习者写了一段较为复杂的代码，运行时没有达到预期效果，人们往往无法通过阅读代码找出问题（错误往往揭示了知识或思维盲区），它需要逐行运行代码，看看效果，然后判断究竟是哪一步出了问题，这就是单步调试之所以如此重要的原因，即便对于专业程序员，也是如此。在<code>灌入式</code>中我们无法做到单步调试，因为代码是一股脑灌入硬件的。但<code>交互式</code>允许我们这样做，因为每次都是消息通信，所以编程界面可以逐步地给硬件发送控制指令。如果你观察过学生在code.org中通过单步调试找到问题，并顺利前行，你就知道这个特性有多棒</p><blockquote><p>   软件编程和硬件编程，不必区分，虚拟角色与现实硬件能彼此联动</p></blockquote><p>在图形化编程这块，学习者很可能是先学了软件编程，通过闯关式的学习，利用积木控制虚拟角色来达到目标，在这个过程中掌握编程概念。<code>交互式</code>硬件编程允许你把硬件也接入到这些web平台里。如此一来，无论是教学软件还是硬件，平台架构上将毫无差别，学生的编程体验也几乎没有差别。它们学习软件编程所积累的知识完全可以用于硬件部分。</p><p>而在创作类平台中(比如scratch)，<code>交互式</code>编程允许虚拟角色与物理硬件彼此沟通，你可以自由联通虚拟与现实世界，制作体感游戏和富有表现力的故事。这将为我们带来更高的<code>高天花板</code>和更多的趣味性，从而点燃大家的热情</p><p>关于这块的有趣例子可以参考:<a href="https://codelab-adapter-docs.codelab.club/user_guide/gallery/" target="_blank" rel="noopener noreferrer">codelab-adapter-docs gallery</a></p><blockquote><p>   强大的可扩展性</p></blockquote><p><code>交互式</code>还将为我们带来强大的可扩展性，<a href="https://zh.wikipedia.org/zh-hans/ROS" target="_blank" rel="noopener noreferrer">ROS(Robot Operating System)</a>和<a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener noreferrer">scratch3_adapter</a>是很好的两个例子。因为基于消息通信，各个部分彼此解耦，这些系统本质上是分布式的，你可以接入任何东西，在<a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener noreferrer">scratch3_adapter</a>中，硬件方面,我们已经接入了:</p><ul><li><a href="http://microbit.org/" target="_blank" rel="noopener noreferrer">micro:bit</a></li><li><a href="https://www.anki.com/en-us/cozmo" target="_blank" rel="noopener noreferrer">Cozmo</a></li><li><a href="https://store.sphero.com/products/bb-8-by-sphero" target="_blank" rel="noopener noreferrer">BB8</a></li><li><a href="https://www.raspberrypi.org/" target="_blank" rel="noopener noreferrer">树莓派</a></li><li><a href="https://blog.just4fun.site/scratch3-smart-home.html">智能家居</a></li></ul><p>AI方面，我们接入了:</p><ul><li><a href="https://azure.microsoft.com/zh-cn/services/cognitive-services/" target="_blank" rel="noopener noreferrer">微软认知服务</a></li><li><a href="https://js.tensorflow.org/" target="_blank" rel="noopener noreferrer">本地化的机器视觉</a></li><li><a href="https://opencv.org/" target="_blank" rel="noopener noreferrer">opencv</a></li><li><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener noreferrer">实时物体检测</a></li><li>一些简单的本地自然语言处理(移植了mit media lab的实验项目)</li></ul><p>如果你愿意，你可以将小时候的玩具四驱车接入进来。</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="如何实现"></a>如何实现<a aria-hidden="true" tabindex="-1" class="hash-link" href="#如何实现" title="Direct link to heading">#</a></h1><blockquote><p> everything is message</p></blockquote><p>天色已晚，明天要早起，这部分就不多写了，之后单独讨论</p><p>如果你熟悉LISP,为了实现一个 LISP REPL，只需要实现read、eval、print三个函数和一个不停轮询的函数(loop)即可,一个基本的REPL就可以用如下的简单形式表达：(loop (print (eval (read))))</p><p>一旦你理解了这个概念，就可以自己动手去硬件上实现了。</p><p>事实上，社区里的交互式项目(如S4A、snap4arduino、s4m)思路基本都是一样的</p><p>我们自己动手实现了<a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener noreferrer">scratch3_adapter</a></p><p>我把写作<a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener noreferrer">scratch3_adapter</a>的过程都记录在博客里，如果你有兴趣，也可以根据最初的架构，自己实现:</p><ul><li><a href="https://blog.just4fun.site/scratch3-plugin-1.html">为Scratch3.0设计的插件系统(上篇)</a></li><li><a href="https://blog.just4fun.site/scratch3-plugin-2.html">为Scratch3.0设计的插件系统(下篇)</a></li><li><a href="https://blog.just4fun.site/Scratch3-Lab.html">Scratch3 Lab: 将Scratch3接入开源硬件及AI的实验项目</a></li><li><a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener noreferrer">codelab-adapter-docs</a></li></ul><p>我私下认为<a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener noreferrer">scratch3_adapter</a>基于zeromq的实现也许是目前扩展性最好的，欢迎入坑 ：）</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="补遗"></a>补遗<a aria-hidden="true" tabindex="-1" class="hash-link" href="#补遗" title="Direct link to heading">#</a></h1><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="通讯补丁"></a>通讯补丁<a aria-hidden="true" tabindex="-1" class="hash-link" href="#通讯补丁" title="Direct link to heading">#</a></h3><p>灌入式编程可以在一定程度上，也可以实现<code>交互</code>特性，一种策略是采用<code>通讯变量</code>的概念, makeblock的mblock很好地利用了这点</p><p>利用通讯变量，你可以让上下位机实现彼此沟通</p><p>技术实现的话，也不会太难，在硬件里跑一个独立的通信进程就行，之后通过uart或其他通道与上位机沟通就行</p><p>你最好将这种方式视为一种补丁，<code>通讯变量</code>是一种补充策略，通过这种补丁，你无法做到<code>交互式</code>的所有特性，但这依然不失为一种很聪明的做法</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_ZqCz" id="参考"></a>参考<a aria-hidden="true" tabindex="-1" class="hash-link" href="#参考" title="Direct link to heading">#</a></h1><ul><li><a href="https://en.wikipedia.org/wiki/Protocol" target="_blank" rel="noopener noreferrer">Protocol</a></li><li><a href="http://hintjens.com/blog:_unprotocols" target="_blank" rel="noopener noreferrer">unprotocols</a></li><li><a href="https://en.scratch-wiki.info/wiki/PicoBoard" target="_blank" rel="noopener noreferrer">PicoBoard</a><ul><li><a href="https://github.com/sparkfun/PicoBoard" target="_blank" rel="noopener noreferrer">sparkfun/PicoBoard</a></li></ul></li><li><a href="https://www.raspberrypi.org/blog/scratch-2-raspberry-pi/" target="_blank" rel="noopener noreferrer">scratch-2-raspberry-pi</a></li><li><a href="http://s4a.cat/" target="_blank" rel="noopener noreferrer">S4A</a></li><li><a href="https://zhuanlan.zhihu.com/p/24770930" target="_blank" rel="noopener noreferrer">Mixly，初学Arduino的最佳图形化编程工具</a></li><li><a href="https://github.com/firmata/protocol" target="_blank" rel="noopener noreferrer">Firmata</a></li><li><a href="http://snap4arduino.rocks/" target="_blank" rel="noopener noreferrer">snap4arduino</a></li><li><a href="https://nick.zoic.org/art/micropython-webusb/" target="_blank" rel="noopener noreferrer">MicroPython with WebUSB!</a></li><li><a href="https://hackernoon.com/software-development-at-1-hz-5530bb58fc0e" target="_blank" rel="noopener noreferrer">Software development at 1 Hz</a></li><li><a href="https://developers.google.com/web/updates/2016/03/access-usb-devices-on-the-web" target="_blank" rel="noopener noreferrer">Access USB Devices on the Web</a></li><li><a href="https://wicg.github.io/webusb/" target="_blank" rel="noopener noreferrer">WebUSB API</a></li><li><a href="https://zh.wikipedia.org/zh-hans/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">读取﹣求值﹣输出循环(REPL)</a></li><li><a href="https://zh.wikipedia.org/wiki/LISP" target="_blank" rel="noopener noreferrer">LISP</a> </li><li><a href="https://zh.wikipedia.org/wiki/%E5%BB%BA%E6%A7%8B%E4%B8%BB%E7%BE%A9_(%E5%AD%B8%E7%BF%92%E7%90%86%E8%AB%96)" target="_blank" rel="noopener noreferrer">建构主义 (学习理论)</a></li><li><a href="https://www.feld.com/archives/2018/07/the-repl-for-hardware.html">The REPL For Hardware</a></li></ul></section><footer class="row margin-vert--lg"><div class="col"><strong>标签：</strong><a class="margin-horiz--sm" href="/blog/tags/编程学习">编程学习</a></div></footer></article><div><a href="https://github.com/CodeLabClub/NewCodeLabWeb/tree/master/blog/Hardware-Programming-style.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2018/07/26/scratch-community-analyze"><div class="pagination-nav__sublabel">上一篇</div><div class="pagination-nav__label">« scratch社区一览</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><ul class="footer__items"><li class="footer__item"><a href="http://discuss.codelab.club/" target="_blank" rel="noopener noreferrer" class="footer__link-item" to="http://discuss.codelab.club/">CodeLab 论坛</a></li></ul></div><div class="col footer__col"><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog/2021/07/21/CodeLab-handbook">手册</a></li></ul></div><div class="col footer__col"><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog/2020/08/20/tools">下载</a></li></ul></div><div class="col footer__col"><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog/2020/04/01/欢迎关注CodeLab微信公众号">微信公众号</a></li></ul></div><div class="col footer__col"><ul class="footer__items"><li class="footer__item"><a href="https://www.zhihu.com/people/codelab-83" target="_blank" rel="noopener noreferrer" class="footer__link-item" to="https://www.zhihu.com/people/codelab-83">在知乎</a></li></ul></div><div class="col footer__col"><ul class="footer__items"><li class="footer__item"><a href="https://space.bilibili.com/607249092" target="_blank" rel="noopener noreferrer" class="footer__link-item" to="https://space.bilibili.com/607249092">在B站</a></li></ul></div></div><div class="text--center"><div>Copyright © 2022 CodeLab&nbsp&nbsp&nbsp<a style="color:white" target="_blank" href="https://beian.miit.gov.cn/">粤ICP备2021005905号-1</a><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3be250eb38d350c4a750c4b0bbfe513e";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></div></div></footer></div>
<script src="/styles.71fb8b2a.js"></script>
<script src="/runtime~main.676e3002.js"></script>
<script src="/main.aad9f3c1.js"></script>
<script src="/1.af123087.js"></script>
<script src="/2.2944d33e.js"></script>
<script src="/3.ffbe02f2.js"></script>
<script src="/ccc49370.9d6295d9.js"></script>
<script src="/c75b8501.558fbb50.js"></script>
</body>
</html>